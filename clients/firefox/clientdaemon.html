<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Deuxdrop Transport</title>
    <script src="../deps/require.js"></script>
    <script>
// The built-in console is not useful to us here in a page-worker!
var log = function() {
  dump(Array.prototype.join.call(arguments, ' ') + "\n");
};
var console = {
  log: log,
  info: log,
  warn: log,
  error: log,
  debug: log,
};

// this is taken from rdservers/cmdline.js
var SUPER_DEBUG = 1;
var MAGIC_ERROR_TRAPPER = {
  _trappedErrors: null,
  _handlerCallback: null,
  /**
   * Express interest in errors.
   */
  trapErrors: function() {
    this._trappedErrors = [];
  },
  callbackOnError: function(handler) {
    this._handlerCallback = handler;
    this._trappedErrors = [];
  },
  yoAnError: function(err, moduleName) {
    if (this._trappedErrors == null || SUPER_DEBUG) {
      console.error("==== REQUIREJS ERR ====", moduleName);
      console.error(err.message);
      console.error(err.stack);
    }
    if (this._handlerCallback)
      this._handlerCallback(err, moduleName);
    else if (this._trappedErrors)
      this._trappedErrors.push(err);
  },
  gobbleAndStopTrappingErrors: function() {
    this._handlerCallback = null;
    var errs = this._trappedErrors;
    this._trappedErrors = null;
    return errs;
  },

  // 'process' helpers pushed out here for dependency reasons across platforms
  on: function() {},
  once: function() {},
  removeListener: function() {},

  reliableOutput: log,
};

require.onError = function(err) {
  var useErr = err;
  if (err.originalError)
    useErr = err.originalError;
  MAGIC_ERROR_TRAPPER.yoAnError(useErr, err.moduleName);
};

function sendAddOnMessage(data) {
  var event = document.createEvent("MessageEvent");
  event.initMessageEvent('moda-addon-message', false, false,
                         JSON.stringify(data), '*', null,
                         null, null);
  window.dispatchEvent(event);
}

var RAW_CLIENT = null, $backside, LOG_REAPER, LOG_SCHEMA, ROOT_LOGGER;
function BOOTSTRAP(callbackWhenLoaded) {
  require(
    {
      baseUrl: '../deps',
      paths: {
        // dumb/trivial stubs
        'child_process': '../../addon/js/child_process',
        'fs': '../../addon/js/fs',
        'http': '../../addon/js/http',
        'microtime': '../../addon/js/microtime',
        'path': '../../addon/js/path',
        'timers': '../../addon/js/timers',
        'util': '../../addon/js/util',
        // testing-informed stubs
        'event-queue': '../../addon/js/event-queue',

        // mozilla shims
        'nacl': '../../addon/js/nacl',
        'websocket': '../../addon/js/websocket',
      },
      catchError: {
        define: true,
      }
    },
    ['event-queue', 'rdcommon/rawclient/acctmgr', 'rdcommon/moda/backside',
     'rdcommon/logreaper'],
    function(_blahq, $acctmgr, _backside, $logreaper) {
      console.log(":) :) :) client daemon bootstrapped!");
      var bundle = $acctmgr.loadAccount();
      RAW_CLIENT = bundle.rawClient;
      $backside = _backside;

      ROOT_LOGGER = bundle.rootLogger;
      LOG_REAPER = new $logreaper.LogReaper(bundle.rootLogger);
      LOG_SCHEMA = bundle.schema;

      if (callbackWhenLoaded)
        callbackWhenLoaded();
    }
  );
}

////////////////////////////////////////////////////////////////////////////////
// Moda Hookup

var backsides = {};
function NEW_MODA_CLIENT(name) {
  console.log("new client", name, "reported alive");
  var backside = backsides[name] =
    new $backside.ModaBackside(RAW_CLIENT, name, ROOT_LOGGER);
  backside._sendObjFunc = function(data) {
    daemonSendClientMessage(name, data);
  }
}

function MODA_CLIENT_MSG(name, data) {
  backsides[name]._received(data);
}

function DEAD_MODA_CLIENT(name) {
  console.log("client", name, "reported dead");
  if (backsides.hasOwnProperty(name)) {
    backsides[name].dead();
    delete backsides[name];
  }
}

////////////////////////////////////////////////////////////////////////////////
// Logger Hookup

/**
 * Maintain a backlog of log messages that we can send to new subscribers so
 *  they don't miss out on anything exciting.
 */
var logbacklog = [], MAX_LOG_BACKLOG = 60;
var loggerClients = [];

// once a second, potentially generate a log 
setInterval(function() {
  var logTimeSlice = LOG_REAPER.reapHierLogTimeSlice();
  // if nothing interesting happened, this could be empty, yos.
  if (logTimeSlice.logFrag) {
    logbacklog.push(logTimeSlice);
    // throw something away if we've got too much stuff already
    if (logbacklog.length > MAX_LOG_BACKLOG)
      logbacklog.shift();
    for (var i = 0; i < loggerClients.length; i++) {
      daemonSendLoggerClientMessage(loggerClients[i],
                                    {type: 'logslice', slice: logTimeSlice});
    }
  }
}, 1000);

function NEW_LOG_CLIENT(name) {
  // wait for the client to tell us about itself since loading can take a while
}

function LOG_CLIENT_MSG(name, msg) {
  if (msg.type === 'subscribe') {
    loggerClients.push(name);
    daemonSendLoggerClientMessage(name, {
      type: 'backlog',
      backlog: logbacklog,
      schema: LOG_SCHEMA
    });
  }
}

function DEAD_LOG_CLIENT(name) {
  var idx = loggerClients.indexOf(name);
  if (idx !== -1)
    loggerClients.splice(idx, 1);
}

////////////////////////////////////////////////////////////////////////////////

window.onerror = function (err) {
  sendAddOnMessage({'ERROR': err.toString()});
};
    </script>
  </head>
  <body>
  </body>
</html>
